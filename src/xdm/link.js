  /**
 * @copyright 2015 Orino Labs GmbH
 * @author Michael BÃ¼rge <mib@orino.ch>
 */


goog.provide('xdm.Link');

goog.require('goog.log');
goog.require('xdm.NativeTransport');


/**
 * @typedef {function(*):void}
 */
xdm.MessageHandler;


/**
 * @param {Window} targetWindow The target window. Beware: An iframe's
 *     contentWindow property is null until it has been attached to the DOM.
 * @param {string} targetOrigin The origin of the document loaded in
 *     the target window.
 * @param {string=} opt_id The link id. Optional because for simple scenarios
 *     this can be autogenerated.
 *     TODO: Document when and why this has to be provided.
 * @constructor
 */
xdm.Link = function(targetWindow, targetOrigin, opt_id) {
  /** @type {Window} */
  this.targetWindow = targetWindow;

  /** @type {string} */
  this.targetOrigin = targetOrigin;

  /** @type {string} */
  this.id = opt_id || [window.location.origin, targetOrigin].sort().join('-');

  /**
   * @type {Array.<{port:string,payload:*}>}
   * @private
   */
  this.queue_ = [];

  /**
   * @type {Object.<string, xdm.MessageHandler>}
   * @private
   */
  this.ports_ = {};
  this.addPort(xdm.Link.SIGNALING_PORT, this.handleSignalingMessage_.bind(this));

  /** @type {xdm.NativeTransport} */
  this.transport = xdm.NativeTransport.getInstance();
  this.transport.registerLink(this);

  // NOTE: Sending can fail at this point, because loading of the target
  // document might not have started yet.
  // The error eventaully reported is not thrown in this
  // execution thread, but asynchronously sometimes later when the browser
  // actually tries to post it to the target window.
  // (15-08-28: Only observed in Chrome so far.)
  this.send(xdm.Link.SIGNALING_PORT, 'init');
  this.logger.info('init message sent')
};


/** @type {goog.debug.Logger} */
xdm.Link.logger = xdm.Link.prototype.logger = goog.log.getLogger('xdm.Link');


/** @type {string} */
xdm.Link.SIGNALING_PORT = '__xdm__';


/**
 * @param {string=} opt_ownOrigin
 * @param {string=} opt_targetOrigin
 * @return {string}
 */
xdm.Link.generateId = function(opt_ownOrigin, opt_targetOrigin) {
  var parts = [];
  // Own and target origin.
  opt_ownOrigin && parts.push(opt_ownOrigin);
  opt_targetOrigin && parts.push(opt_targetOrigin);
  // Random chars.
  parts.push(Math.floor(Math.random() * Math.pow(36, 6)).toString(36));
  // Counter.
  if (!xdm.Link.count) xdm.Link.count = 0;
  var count = xdm.Link.count++;
  parts.push(count);
  return parts.join('-');
};


/**
 * Whether the link has been established (handshake exchanged).
 * @type {boolean}
 * @private
 */
xdm.Link.prototype.established_ = false;


/**
 * @param {string} name
 * @param {xdm.MessageHandler} handler
 */
xdm.Link.prototype.addPort = function(name, handler) {
  this.ports_[name] = handler;
};


/**
 * @param {*} msg
 * @private
 */
xdm.Link.prototype.handleSignalingMessage_ = function(msg) {
  if (msg == 'init' && !this.established_) {
    this.established_ = true;
    this.send(xdm.Link.SIGNALING_PORT, 'init');

    this.logger.info('Link established (' + this.id + ')');

    this.queue_.forEach(function(rec) {
        this.send(rec.port, rec.payload);
      }.bind(this));
    this.queue_ = null;
  }
};


/**
 * @param {string} port
 * @param {*} payload
 */
xdm.Link.prototype.send = function(port, payload) {
  if (!this.established_ && port != xdm.Link.SIGNALING_PORT) {
    this.queue_.push({port:port, payload:payload});
  }

  var data = {
    'linkId': this.id,
    'port': port,
    'payload': payload
  };

  this.logger.fine('#send: ' + JSON.stringify(data));
  this.transport.send(this, data);
};


/**
 * @param {string} port
 * @param {*} payload
 */
xdm.Link.prototype.deliver = function(port, payload) {
  this.logger.fine('#deliver: ' + port + ': ' + JSON.stringify(payload));
  var handler = this.ports_[port];
  if (handler) {
    handler(payload);
  } else {
    xdm.Link.logger.info('No such port: ' + port);
  }
};

