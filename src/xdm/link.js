/**
 * @copyright 2015 Orino Labs GmbH
 * @author Michael BÃ¼rge <mib@orino.ch>
 */


goog.provide('xdm.Link');

goog.require('goog.log');
goog.require('xdm.NativeTransport');

/**
 * @typedef {function(Object)}
 */
xdm.MessageHandler;


/**
 * @param {Window} targetWindow The target window. Beware: An iframe's
 *     contentWindow property is null until it has been attached to the DOM.
 * @param {string} targetOrigin The origin of the document loaded in
 *     the target window.
 * @param {string=} opt_id The link id. Optional because for simple scenarios
 *     this can be autogenerated.
 *     TODO: Document when and why this has to be provided.
 * @constructor
 */
xdm.Link = function(targetWindow, targetOrigin, opt_id) {
  /** @type {Window} */
  this.targetWindow = targetWindow;

  /** @type {string} */
  this.targetOrigin = targetOrigin;

  /** @type {string} */
  this.id = opt_id || [window.location.origin, targetOrigin].sort().join('-');

  /**
   * @type {Array.<{port:string,payload:*}>}
   * @private
   */
  this.queue_ = [];

  /**
   * @type {Object.<string, xdm.MessageHandler>}
   * @private
   */
  this.ports_ = {};
  this.addPort(xdm.Link.SIGNALING_PORT, this.handleSignalingMessage_.bind(this));

  /** @type {xdm.NativeTransport} */
  this.transport = xdm.NativeTransport.getInstance();
  this.transport.registerLink(this);

  this.send(xdm.Link.SIGNALING_PORT, 'init');
};


/** @type {goog.debug.Logger} */
xdm.Link.logger = xdm.Link.prototype.logger = goog.log.getLogger('xdm.Link');


xdm.Link.SIGNALING_PORT = '__xdm__';

/**
 * Whether the link has been established (handshake exchanged).
 * @type {boolean}
 * @private
 */
xdm.Link.prototype.established_ = false;


/**
 * @param {string} name
 * @param {xdm.MessageHandler} handler
 */
xdm.Link.prototype.addPort = function(name, handler) {
  this.ports_[name] = handler;
};


/**
 * @param {string} msg
 */
xdm.Link.prototype.handleSignalingMessage_ = function(msg) {
  if (msg == 'init' && !this.established_) {
    this.established_ = true;
    this.send(xdm.Link.SIGNALING_PORT, 'init');

    this.queue_.forEach(function(rec) {
        this.send(rec.port, rec.payload);
      }.bind(this));
    this.queue_ = null;
  }
};


/**
 * @param {string} port
 * @param {*} payload
 */
xdm.Link.prototype.send = function(port, payload) {
  if (!this.established_ && port != xdm.Link.SIGNALING_PORT) {
    this.queue_.push({port:port, payload:payload});
  }

  var data = {
    'linkId': this.id,
    'port': port,
    'payload': payload
  };

  this.logger.fine('#send: ' + JSON.stringify(data));
  this.transport.send(this, data);
};


/**
 * @param {string} port
 * @param {*} payload
 */
xdm.Link.prototype.deliver = function(port, payload) {
  this.logger.fine('#deliver: ' + port + ': ' + JSON.stringify(payload));
  var handler = this.ports_[port];
  if (handler) {
    handler(payload);
  } else {
    xdm.Link.logger.info('No such port: ' + port);
  }
};

